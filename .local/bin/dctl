#!/usr/bin/env python3

import argparse
import filecmp
import shutil
import subprocess
import tempfile
from difflib import SequenceMatcher
from pathlib import Path

# Constants for file paths and configuration
USER_APPS = Path.home() / ".local/share/applications"
SYSTEM_APPS = Path("/usr/share/applications")
USER_AUTOSTART = Path.home() / ".config/autostart"
SYSTEM_AUTOSTART = Path("/etc/xdg/autostart")
MAX_LINE_WIDTH = 80

def get_desktop_files(paths: list[Path]) -> list[Path]:
    """Collect all .desktop files from given directories."""
    desktop_files = []
    for path in paths:
        if path.exists():
            desktop_files.extend(path.rglob(f"*{".desktop"}"))
    return desktop_files

def extract_desktop_field(file_path: Path, field_name: str) -> str:
    """Extract value from a .desktop file for the specified field."""
    try:
        with file_path.open("r", encoding="utf-8") as f:
            for line in f:
                if line.strip().lower().startswith(f"{field_name}="):
                    return line.partition("=")[2].strip()
    except (OSError, UnicodeDecodeError):
        pass
    return ""

def calculate_match_score(query: str, file_path: Path) -> tuple[int, int]:
    """Calculate match score between query and file name/desktop name."""
    query_lc = query.lower()
    file_name = file_path.stem.lower()
    desktop_name = extract_desktop_field(file_path, "name").lower()

    def get_match_metrics(target: str) -> tuple[int, int]:
        """Calculate unmatched characters and extra characters for a target string."""
        match_size = SequenceMatcher(None, query_lc, target).find_longest_match().size
        unmatched_chars = len(query_lc) - match_size
        extra_chars = len(target) - match_size
        return unmatched_chars, extra_chars

    file_unmatched, file_extra = get_match_metrics(file_name)
    desktop_unmatched, desktop_extra = get_match_metrics(desktop_name)

    # Prefer the better match (less unmatched characters)
    if desktop_unmatched < file_unmatched:
        return desktop_unmatched, desktop_extra
    return file_unmatched, file_extra

def find_matching_files(query: str, search_paths: list[Path]) -> list[tuple[int, int, Path]]:
    """Find .desktop files matching the query and return sorted results."""
    candidates = []
    for file_path in get_desktop_files(search_paths):
        unmatched, extra = calculate_match_score(query, file_path)
        if unmatched <= 0:  # Only consider matches
            candidates.append((unmatched, extra, file_path))
    
    # Primary sort: unmatched chars (lower is better)
    # Secondary sort: extra chars (lower is better)
    return sorted(candidates, key=lambda x: (x[0], x[1]))

def format_file_entry(
    file_path: Path,
    max_combined_width: int,
    debug_info: tuple[int, int] = None
) -> str:
    """Format file entry with consistent alignment in both modes."""
    name_field = extract_desktop_field(file_path, "name") or "(name not found)"
    
    if debug_info:
        debug_str = f"[{debug_info[0]}, {debug_info[1]}]  "
        path_part = str(file_path)
        combined = debug_str + path_part
        padding = max(0, max_combined_width - len(combined))
        return f"{combined}{' ' * padding} > {name_field}"
    
    path_part = f"  {file_path}"
    padding = max(0, max_combined_width - len(path_part))
    return f"{path_part}{' ' * padding} > {name_field}"

def display_matches(matches: list[tuple[int, int, Path]], debug: bool = False):
    """Display matches with perfect alignment in both modes."""
    if not matches:
        print("No matching files found")
        return

    # Calculate maximum combined width (debug + path or just path)
    if debug:
        max_combined = max(len(f"[{u}, {e}]  {f}") for u, e, f in matches)
    else:
        max_combined = max(len(f"  {f}") for _, _, f in matches)
    
    max_combined = min(max_combined, MAX_LINE_WIDTH)
    
    for unmatched, extra, file_path in matches:
        print(format_file_entry(
            file_path,
            max_combined,
            (unmatched, extra) if debug else None
        ))

def display_all_files(paths: list[Path]):
    """List all .desktop files in given paths."""
    files = get_desktop_files(paths)
    if not files:
        print("No files found")
        return

    max_path_len = min(MAX_LINE_WIDTH, max(len(str(f)) for f in files))
    for file_path in files:
        print(format_file_entry(file_path, max_path_len))

def parse_header_options(header_text: str) -> tuple[Path | None, str | None]:
    """Parse SavePath and SaveFilename from header text."""
    save_path, save_filename = None, None
    for line in header_text.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("SavePath ="):
            raw = line.partition("=")[2].strip()
            save_path = Path(raw).expanduser()
        elif line.startswith("SaveFilename ="):
            save_filename = line.partition("=")[2].strip()
    return save_path, save_filename


def edit_desktop_file(query: str, search_paths: list[Path], override_dir: Path):
    """Edit a .desktop file with override capability + header options."""
    matches = find_matching_files(query, search_paths)
    if not matches:
        print(f"No match found for '{query}'")
        return

    _, _, original_path = matches[0]
    override_path = override_dir / original_path.name
    override_path.parent.mkdir(parents=True, exist_ok=True)

    print(f"Original file: {original_path}")
    print(f"Override file: {override_path}")

    # Prepare header + body
    header = (
        f"# Original file: {original_path}\n"
        f"SavePath = {override_dir}\n"
        f"# SavePath = ~/.config/autostart/\n"
        f"SaveFilename = {original_path.name}\n\n"
        "# Anything above will not be included in the .desktop file\n"
    )
    body = original_path.read_text(encoding="utf-8")

    # Create descriptive temp file name
    source_tag = "@usr" if "/usr/" in str(original_path) else "@home"
    temp_prefix = f"{source_tag} {original_path.stem} "

    with tempfile.NamedTemporaryFile(
        mode="w+",
        delete=False,
        suffix=".desktop",
        prefix=temp_prefix,
        dir="/tmp"
    ) as tmp_file:
        tmp_path = Path(tmp_file.name)
        tmp_file.write(header + body)
        tmp_file.flush()

    print(f"Opening editor: {tmp_path}")
    subprocess.call(["code", "--wait", str(tmp_path)])

    if not tmp_path.exists():
        print("Edit cancelled, no changes saved")
        return

    edited_text = tmp_path.read_text(encoding="utf-8")

    # Split header and body back
    if "\n[Desktop Entry]" in edited_text:
        header_part, body_part = edited_text.split("\n[Desktop Entry]", 1)
        body_part = "[Desktop Entry]" + body_part
    else:
        print("Invalid file format: missing [Desktop Entry]")
        tmp_path.unlink()
        return

    save_path, save_filename = parse_header_options(header_part)
    if not save_path:
        save_path = override_dir
    if not save_filename:
        save_filename = original_path.name

    save_path.mkdir(parents=True, exist_ok=True)
    final_path = save_path / save_filename

    # If unchanged compared to original, donâ€™t save
    if filecmp.cmp(tmp_path, original_path, shallow=False):
        print("No changes detected")
        tmp_path.unlink()
        return

    final_path.write_text(body_part, encoding="utf-8")
    tmp_path.unlink()
    print(f"Override saved to: {final_path}")




# Command handlers
def handle_dfind(query: str, debug: bool = False):
    """Find desktop application files."""
    matches = find_matching_files(query, [USER_APPS, SYSTEM_APPS])
    display_matches(matches, debug)

def handle_dedit(query: str):
    """Edit desktop application file."""
    edit_desktop_file(query, [USER_APPS, SYSTEM_APPS], USER_APPS)

def handle_dlist():
    """List all desktop applications."""
    display_all_files([USER_APPS, SYSTEM_APPS])

def handle_afind(query: str, debug: bool = False):
    """Find autostart files."""
    matches = find_matching_files(query, [USER_AUTOSTART, SYSTEM_AUTOSTART])
    display_matches(matches, debug)

def handle_aedit(query: str):
    """Edit autostart file."""
    edit_desktop_file(query, [USER_AUTOSTART, SYSTEM_AUTOSTART], USER_AUTOSTART)

def handle_alist():
    """List all autostart entries."""
    display_all_files([USER_AUTOSTART, SYSTEM_AUTOSTART])

def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(description="Manage .desktop files")
    subparsers = parser.add_subparsers(dest="command", required=True)

    commands = {
        "dfind": (handle_dfind, "Find desktop applications"),
        "dedit": (handle_dedit, "Edit desktop application override"),
        "dlist": (handle_dlist, "List desktop applications"),
        "afind": (handle_afind, "Find autostart entries"),
        "aedit": (handle_aedit, "Edit autostart override"),
        "alist": (handle_alist, "List autostart entries"),
    }

    for cmd, (handler, help_text) in commands.items():
        cmd_parser = subparsers.add_parser(cmd, help=help_text)
        if cmd in ("dfind", "afind"):
            cmd_parser.add_argument("query")
            cmd_parser.add_argument("--debug", action="store_true", 
                                    help="Show match scores for debugging")
        elif cmd in ("dedit", "aedit"):
            cmd_parser.add_argument("query")

    args = parser.parse_args()
    command_handlers = {
        "dfind": lambda: handle_dfind(args.query, args.debug),
        "dedit": lambda: handle_dedit(args.query),
        "dlist": handle_dlist,
        "afind": lambda: handle_afind(args.query, args.debug),
        "aedit": lambda: handle_aedit(args.query),
        "alist": handle_alist,
    }

    command_handlers[args.command]()

if __name__ == "__main__":
    main()